# このComposerヘルプ

このドキュメントは、Composerを使用する際の注意点や一般的な問題の解決方法をまとめたものです。
新しいセッションでComposerを使用する際に、同じ問題を回避するために参照してください。

## ドキュメントの構成

このドキュメントは以下のように構成されています：

1. 一般的な問題と解決策
2. 実行時の注意点
3. 環境固有の問題
4. ベストプラクティス

新しい問題や解決策を追加する際は、適切なセクションに追加してください。
各セクションの末尾に追加し、必要に応じて新しいセクションを作成することができます。

## 一般的な問題と解決策

### 1. プロンプトの停止問題
- **現象**: コマンド実行時にプロンプトが停止し、処理が進まなくなる
- **原因**: `&&`で連結された複数のコマンドの実行時に、途中で停止する場合がある
- **対策**:
  - コマンドを個別に実行する
  - 実行前に現在の状態（カレントディレクトリ、ブランチなど）を確認する

### 2. パスの解決問題
- **現象**: ファイルパスが見つからないエラー
- **原因**: カレントディレクトリが意図しないディレクトリになっている
- **対策**:
  - コマンド実行前に`pwd`で現在のディレクトリを確認
  - 必要に応じて適切なディレクトリに移動
  - 相対パスを使用する際は、カレントディレクトリからの正しいパスを指定

### 3. データベース操作の問題
- **現象**: データベースのリセットやシードデータの適用が正しく行われない
- **原因**: マイグレーションファイルの順序や依存関係の問題
- **対策**:
  - リセット実行前にマイグレーションファイルの順序確認
  - シードファイルの内容が最新であることを確認
  - リセット後にデータが正しく挿入されたか確認クエリを実行

### 4. Git操作の問題
- **現象**: ファイルの追加やコミットが失敗する
- **原因**: カレントディレクトリの問題や、パスの指定ミス
- **対策**:
  - Git操作前に`git status`で状態確認
  - プロジェクトルートディレクトリから操作を行う
  - 正しい相対パスでファイルを指定

### 5. 環境変数とコンテナの問題
- **現象**: Dockerコンテナ内でのコマンド実行時にエラー
- **原因**: 環境変数の未設定や、コンテナの起動状態の問題
- **対策**:
  - `docker ps`でコンテナの状態を確認
  - 必要な環境変数が設定されているか確認
  - コンテナ名が正しいか確認

### 6. PRの本文作成の問題
- **現象**: PRの本文で改行コードが`\n`として表示されたり、文字列がエスケープされてしまう
- **原因**: コマンドラインでPRを作成する際の文字列の扱い方の問題
- **対策**:
  - 一時ファイルを作成して`cat`コマンドで内容を読み込む
    ```bash
    # 一時ファイルにPRの本文を書く
    cat > pr-body.md << 'EOF'
    # 概要
    変更内容の概要を書く

    # 変更内容
    - 変更点1
    - 変更点2
    EOF

    # 一時ファイルの内容をPRの本文として使用
    gh pr create --body "$(cat pr-body.md)"
    ```
  - PRの本文を更新する場合も同様
    ```bash
    gh pr edit [PR番号] --body "$(cat pr-body.md)"
    ```
  - 作業完了後は一時ファイルを削除
    ```bash
    rm pr-body.md
    ```

### 7. PRのタイトル作成の問題
- **現象**: PRのタイトルが英語で書かれており、内容が理解しづらい
- **原因**: PRのタイトルを英語で書くことによる意図の伝達ミス
- **対策**:
  - PRのタイトルは日本語で記載する
  - 例：
    - ❌ "Add user authentication"
    - ⭕️ "ユーザー認証機能を追加"
    - ❌ "Fix database connection"
    - ⭕️ "データベース接続エラーを修正"

### 8. Gitブランチの命名規則
- **規則**: 機能追加のブランチは以下の形式で命名する
  ```bash
  # 正しい方法：dateコマンドで現在の年月を取得
  current_date=$(date '+%Y%m')
  feature/${current_date}/author/function-name
  ```
  - `YYYYMM`: dateコマンドで取得した年月（例：202402）
  - `author`: 作成者名
  - `function-name`: 機能名（ハイフン区切り）
- **例**:
  - ❌ `feature/202501/yousan/update-composerhelp`  # 手動で日付入力
  - ⭕️ `feature/$(date '+%Y%m')/yousan/update-composerhelp`  # dateコマンドで取得
- **補足**: 
  - 現在年月は必ずdateコマンドで取得すること
  - モデルや手動入力の日付は使用しないこと
- **参考**: https://qiita.com/yousan/items/f0801437644527b00342

### Gitのブランチングについて
- ブランチングはGitFlowに沿ったものとする。
- mainブランチを本番環境のブランチ、とし、developブランチを開発ブランチとする。
- 機能追加はすべてfeatureブランチで行う。
- 行っている作業に応じてfeatureブランチを作成して作業する。

### PRの作成ルール
1. ベースブランチの指定
   - PRは必ずGitHub上のデフォルトブランチ（現在はdevelop）宛に作成する
   - mainブランチへのマージはリリース時のみとする

2. PRの本文フォーマット
   ```markdown
   # 概要
   変更の概要を簡潔に記載

   # 変更内容
   - 変更点1
   - 変更点2
   ```

3. PRのタイトル
   - 日本語で記載
   - 変更内容が明確に分かるようにする
   - 例：
     - ❌ "Fix database"
     - ⭕️ "データベースマイグレーションの修正"

## 実行時の注意点

### コマンド実行前のチェックリスト
1. カレントディレクトリの確認
2. Gitブランチの確認
3. 必要なファイルの存在確認
4. コンテナの状態確認

### エラー発生時の対応手順
1. エラーメッセージの詳細確認
2. 環境変数やコンテナの状態確認
3. 必要に応じて個別のコマンドとして実行
4. デバッグモードでの実行（`--debug`オプションの使用）

### データ操作時の確認事項
1. バックアップの作成
2. テストデータの準備
3. 実行後の検証クエリの用意
4. ロールバック手順の確認

## ベストプラクティス

1. 複雑なコマンドは個別に実行
2. 実行前に現在の状態を確認
3. エラー時は一つずつ問題を切り分けて対応
4. 重要な操作前にはバックアップを作成
5. テスト実行で動作確認を行ってから本番実行

## 新しい問題や解決策の追加方法

1. 適切なセクションを選択
2. 以下の形式で追加：
   ```markdown
   ### [問題番号]. [問題の名称]
   - **現象**: [問題の現象]
   - **原因**: [考えられる原因]
   - **対策**: [解決方法]
   ```
3. 必要に応じて新しいセクションを作成
4. 目次の更新 

## DB定義について
DB定義はmermaid形式でER図を作成してください。またカラムごとのコメントを日本語で残してください。

## DB（Supabase）のテストについて
- db_test というディレクトリの中にテストコードを描いてください。テストデータは seed.sql を参照してその前提で進めてもらって大丈夫です。

## あなたの役割

あなたは、明確で読みやすいReact、RefineとTypeScriptコードを作成することに特化した専門のAIプログラミングアシスタントです。  
常に最新の安定版のTypeScript、JavaScript、React、Node.js、Next.js、Shadcn UI、Tailwind CSS、Refineを使用し、最新の機能とベストプラクティスに精通しています。  
AI駆動のチャット、コードスタイルと構造、命名規則、TypeScriptの使用、UIとスタイリング、パフォーマンス最適化において正確で事実に基づいた思慮深い回答を提供します。  
以下のルールに従う必要があります：

- Reactファイルはnext-app/srcディレクトリに定義します。
- Supabaseファイルはsupabaseディレクトリに配置します。
- React v18を使用してReactDOM.createRootでルートを作成し、StrictModeでラップしてレンダリングします。
- 画像表示には必ずnext/imageの`Image`コンポーネントを使用し、width、height、altプロパティを適切に設定します。
- migrationファイルはテーブルごとにファイルを分けてください。
- migrationファイルを作成・変更したら cd supabase && supabase db reset && supabase gen types --lang=typescript --local > ../next-app/src/types/database.types.ts && cd ../next-app を実行してください。
- 日付のformatは2000年11月11日のようにYYYY年MM月DD日としてください。
- 時間のformatは11時11分のようにHH時MM分としてください。
- フロントの機能や不具合を修正したら、next-app/cypress内のテストコードを修正してください。その後、cypressのcliコマンドでそのテストが通過することを必ず確認してください。
- /next-app/src/providers/data-provider/custom-data-provider.ts にカスタムロジックを変更してください。
- コミットログのフォーマットは - ${verb} ${message} とし英語で記載してください。

## refineドキュメント

### 認証されたページを作成するには
認証されたページを作成するには、次のように<Authenticated>でコンテンツをラップします：
```tsx
import { Authenticated } from "@refinedev/core";
<Authenticated>
  <div>This page is only accessible to authenticated users.</div>
</Authenticated>
```

### 認証状態の確認
認証状態を確認するには、`useIsAuthenticated`フックを使用します：
```tsx
const { data: isAuthenticated } = useIsAuthenticated();
```

`isAuthenticated`は以下のような形式のオブジェクトを返します：
```ts
{
    authenticated: boolean;    // 認証状態
    redirectTo: string;       // 未認証時のリダイレクト先
    logout: boolean;          // ログアウト状態
}
```

### リアルタイム通信を実装する場合は？
リアルタイムの更新を実装する場合は、Refineの`useSubscription`フックを使用してください：
```tsx
import { useSubscription } from "@refinedev/core";

useSubscription({
    channel: "resources/[resource-name]",
    types: ["created", "updated", "deleted"],
    onLiveEvent: (event) => {
        // イベントに応じたデータ更新処理
    },
});
```

### shadcnのコンポーネントのインストールする方法
フロントエンドのビルド、実行の際にshadcnのコンポーネントを使用する場合や新たにパッケージを追加した場合には必要に応じて下記のコマンドを実行してください。

```bash
cd next-app && npx shadcn@latest add ${component-name}
```

# データベース更新のルール

## データベース定義の更新手順

データベースの構造を変更する際は、以下の手順に従ってください：

1. マイグレーションファイルの作成・更新
   - 新しい変更は既存のマイグレーションファイルを更新
   - ファイル名は`YYYYMMDD000000_description.sql`の形式
   - コメントを必ず追加し、変更内容を明確に
   - ロールバック手順も考慮する

2. ドキュメントの更新
   - `docs/database.md`のER図を更新
   - テーブル定義を更新
   - ENUMタイプの定義を更新（必要な場合）
   - カラムの説明を日本語で追加
   - リレーションシップの更新

3. シードデータの更新
   - `supabase/seed.sql`の更新
   - 新しいカラムに適切なテストデータを追加
   - データの整合性を確認
   - コメントで各データの意図を説明

4. 型定義の更新
   - データベースをリセットして型定義を更新
   ```bash
   cd supabase && supabase db reset && supabase gen types --lang=typescript --local > ../next-app/src/types/database.types.ts && cd ../next-app
   ```

5. テストの更新
   - `db_test`ディレクトリ内のテストコードを更新
   - 新しいカラムのテストが追加されているか
   - 既存のテストが更新されているか
   - エッジケースが考慮されているか

6. RLSポリシーの更新
   - 新しいカラムに対するアクセス制御を設定
   - 適切な権限設定を確認
   - セキュリティの考慮

## コミットメッセージのフォーマット

データベース更新時のコミットメッセージは以下の形式で記述：

```
- update database: ${変更内容}
  
例：
- update database: add role column to profiles table
- update database: modify lesson_schedules status constraints
```

## レビュー時の確認事項

1. マイグレーションファイル
   - 適切なコメントが追加されているか
   - ロールバック手順が考慮されているか
   - 依存関係が正しく設定されているか

2. ドキュメント
   - ER図が更新されているか
   - テーブル定義が更新されているか
   - カラムの説明が日本語で追加されているか
   - リレーションシップが正しく記載されているか

3. シードデータ
   - テストデータが追加されているか
   - データの整合性は保たれているか
   - 各データの意図が明確か

4. テストコード
   - 新しいカラムのテストが追加されているか
   - 既存のテストが更新されているか
   - エッジケースが考慮されているか

5. セキュリティ
   - RLSポリシーが適切に設定されているか
   - アクセス制御が適切か
   - データの整合性が保たれているか

## 変更適用後の確認事項

1. マイグレーションの実行
   - エラーなく実行できたか
   - ロールバックが正常に動作するか

2. シードデータの投入
   - データが正しく挿入されているか
   - 制約違反が発生していないか

3. アプリケーションの動作
   - 既存の機能が正常に動作するか
   - 新機能が期待通り動作するか

4. パフォーマンス
   - インデックスが適切に設定されているか
   - クエリのパフォーマンスに問題ないか

## 外部テーブル参照のルール

1. 外部キーカラム名の命名規則
   - 参照先のテーブル名を含める
   - 単数形で記述
   - 例：
     - ❌ `schedule_id`
     - ⭕️ `lesson_schedule_id`
     - ❌ `user_id`
     - ⭕️ `auth_user_id`

2. 外部キー制約の設定
   - `ON DELETE CASCADE`または`ON DELETE SET NULL`を必ず指定
   - 例：
     ```sql
     REFERENCES lesson_schedules(id) ON DELETE CASCADE
     REFERENCES auth.users(id) ON DELETE CASCADE
     ```

3. インデックスの作成
   - 外部キーには必ずインデックスを作成
   - インデックス名は`idx_テーブル名_カラム名`の形式
   - 例：
     ```sql
     CREATE INDEX idx_reservations_lesson_schedule_id ON reservations(lesson_schedule_id);
     CREATE INDEX idx_reservations_auth_user_id ON reservations(auth_user_id);
     ```

## マイグレーションファイルのルール

1. ファイル命名規則
   - 形式：`YYYYMMDD000000_description.sql`
   - 例：
     - ❌ `20240128_create_tables.sql`
     - ⭕️ `20240128000001_create_profiles.sql`

2. ファイル構成
   - ENUMタイプの定義
   - テーブルの作成
   - カラムコメントの追加
   - インデックスの作成
   - トリガーの作成
   - 例：
     ```sql
     -- Create enum types
     CREATE TYPE user_role AS ENUM ('admin', 'instructor', 'student');

     -- Create table
     CREATE TABLE profiles (
         id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
         ...
     );

     -- Add column comments
     COMMENT ON COLUMN profiles.id IS 'プロファイルID';
     ...

     -- Create indexes
     CREATE INDEX idx_profiles_user_id ON profiles(user_id);
     ...

     -- Create triggers
     CREATE TRIGGER update_profiles_updated_at
         BEFORE UPDATE ON profiles
         FOR EACH ROW
         EXECUTE FUNCTION update_updated_at_column();
     ```

3. コメントの記述
   - すべてのカラムに日本語でコメントを追加
   - 外部キー参照の場合は参照先のテーブルも明記
   - 例：
     ```sql
     COMMENT ON COLUMN reservations.lesson_schedule_id IS 'レッスンスケジュールID（lesson_schedulesテーブルの外部キー）';
     ```

4. タイムスタンプの設定
   - `created_at`と`updated_at`カラムを必ず追加
   - デフォルト値とトリガーを設定
   - 例：
     ```sql
     created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
     updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
     ```

5. 依存関係の考慮
   - 外部キー参照先のテーブルが先に作成されていることを確認
   - マイグレーションファイルの番号で順序を制御
   - 例：
     - `20240128000001_common.sql`（共通関数）
     - `20240128000002_profiles.sql`（プロファイル）
     - `20240128000003_lessons.sql`（レッスン）
     - `20240128000004_lesson_schedules.sql`（レッスンスケジュール）

6. ロールバック手順の考慮
   - 各テーブルの削除順序を考慮
   - 依存関係の逆順で削除
   - 例：
     ```sql
     -- テーブル作成時
     CREATE TABLE profiles ...
     CREATE TABLE lessons ...
     CREATE TABLE lesson_schedules ...

     -- ロールバック時
     DROP TABLE lesson_schedules;
     DROP TABLE lessons;
     DROP TABLE profiles;
     ```

## タイムゾーンのルール

1. 基本設定
   - すべてのタイムゾーンはJST（日本標準時）を使用する
   - データベースのタイムスタンプはJSTで保存・取得する

2. マイグレーションファイルでの設定
   - タイムスタンプのデフォルト値は以下のように設定する：
     ```sql
     created_at TIMESTAMP WITH TIME ZONE DEFAULT (current_timestamp AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Tokyo') NOT NULL,
     updated_at TIMESTAMP WITH TIME ZONE DEFAULT (current_timestamp AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Tokyo') NOT NULL
     ```

3. アプリケーションでの表示
   - フロントエンドでの日時表示は必ずJSTで行う
   - 日付フォーマット：YYYY年MM月DD日
   - 時間フォーマット：HH時MM分

4. データ操作時の注意点
   - データベースへの挿入時は必ずJSTで行う
   - タイムゾーンの変換が必要な場合は、明示的に`Asia/Tokyo`を指定する
   - 例：
     ```sql
     INSERT INTO lesson_schedules (start_time, end_time)
     VALUES 
     ('2024-02-01 10:00:00+09'::timestamptz, '2024-02-01 12:00:00+09'::timestamptz);
     ```

